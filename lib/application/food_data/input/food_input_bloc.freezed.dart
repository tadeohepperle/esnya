// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'food_input_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FoodInputEventTearOff {
  const _$FoodInputEventTearOff();

  Reset reset() {
    return const Reset();
  }

  SetVolatileText setVolatileText(String text) {
    return SetVolatileText(
      text,
    );
  }

  MakeVolatileTextSafe makeVolatileTextSafe() {
    return const MakeVolatileTextSafe();
  }

  BuildFragments buildFragments() {
    return const BuildFragments();
  }

  ApplyFragments applyFragments(FragmentizationResult fragmentizationResult) {
    return ApplyFragments(
      fragmentizationResult,
    );
  }

  FetchFoodForFoodItemEntry fetchFoodForFoodItemEntry(
      FoodItemEntryPreSuccess foodItemEntryPreSuccess) {
    return FetchFoodForFoodItemEntry(
      foodItemEntryPreSuccess,
    );
  }
}

/// @nodoc
const $FoodInputEvent = _$FoodInputEventTearOff();

/// @nodoc
mixin _$FoodInputEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoodInputEventCopyWith<$Res> {
  factory $FoodInputEventCopyWith(
          FoodInputEvent value, $Res Function(FoodInputEvent) then) =
      _$FoodInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$FoodInputEventCopyWithImpl<$Res>
    implements $FoodInputEventCopyWith<$Res> {
  _$FoodInputEventCopyWithImpl(this._value, this._then);

  final FoodInputEvent _value;
  // ignore: unused_field
  final $Res Function(FoodInputEvent) _then;
}

/// @nodoc
abstract class $ResetCopyWith<$Res> {
  factory $ResetCopyWith(Reset value, $Res Function(Reset) then) =
      _$ResetCopyWithImpl<$Res>;
}

/// @nodoc
class _$ResetCopyWithImpl<$Res> extends _$FoodInputEventCopyWithImpl<$Res>
    implements $ResetCopyWith<$Res> {
  _$ResetCopyWithImpl(Reset _value, $Res Function(Reset) _then)
      : super(_value, (v) => _then(v as Reset));

  @override
  Reset get _value => super._value as Reset;
}

/// @nodoc

class _$Reset implements Reset {
  const _$Reset();

  @override
  String toString() {
    return 'FoodInputEvent.reset()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Reset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class Reset implements FoodInputEvent {
  const factory Reset() = _$Reset;
}

/// @nodoc
abstract class $SetVolatileTextCopyWith<$Res> {
  factory $SetVolatileTextCopyWith(
          SetVolatileText value, $Res Function(SetVolatileText) then) =
      _$SetVolatileTextCopyWithImpl<$Res>;
  $Res call({String text});
}

/// @nodoc
class _$SetVolatileTextCopyWithImpl<$Res>
    extends _$FoodInputEventCopyWithImpl<$Res>
    implements $SetVolatileTextCopyWith<$Res> {
  _$SetVolatileTextCopyWithImpl(
      SetVolatileText _value, $Res Function(SetVolatileText) _then)
      : super(_value, (v) => _then(v as SetVolatileText));

  @override
  SetVolatileText get _value => super._value as SetVolatileText;

  @override
  $Res call({
    Object? text = freezed,
  }) {
    return _then(SetVolatileText(
      text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SetVolatileText implements SetVolatileText {
  const _$SetVolatileText(this.text);

  @override
  final String text;

  @override
  String toString() {
    return 'FoodInputEvent.setVolatileText(text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetVolatileText &&
            const DeepCollectionEquality().equals(other.text, text));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(text));

  @JsonKey(ignore: true)
  @override
  $SetVolatileTextCopyWith<SetVolatileText> get copyWith =>
      _$SetVolatileTextCopyWithImpl<SetVolatileText>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return setVolatileText(text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return setVolatileText?.call(text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (setVolatileText != null) {
      return setVolatileText(text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return setVolatileText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return setVolatileText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (setVolatileText != null) {
      return setVolatileText(this);
    }
    return orElse();
  }
}

abstract class SetVolatileText implements FoodInputEvent {
  const factory SetVolatileText(String text) = _$SetVolatileText;

  String get text;
  @JsonKey(ignore: true)
  $SetVolatileTextCopyWith<SetVolatileText> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MakeVolatileTextSafeCopyWith<$Res> {
  factory $MakeVolatileTextSafeCopyWith(MakeVolatileTextSafe value,
          $Res Function(MakeVolatileTextSafe) then) =
      _$MakeVolatileTextSafeCopyWithImpl<$Res>;
}

/// @nodoc
class _$MakeVolatileTextSafeCopyWithImpl<$Res>
    extends _$FoodInputEventCopyWithImpl<$Res>
    implements $MakeVolatileTextSafeCopyWith<$Res> {
  _$MakeVolatileTextSafeCopyWithImpl(
      MakeVolatileTextSafe _value, $Res Function(MakeVolatileTextSafe) _then)
      : super(_value, (v) => _then(v as MakeVolatileTextSafe));

  @override
  MakeVolatileTextSafe get _value => super._value as MakeVolatileTextSafe;
}

/// @nodoc

class _$MakeVolatileTextSafe implements MakeVolatileTextSafe {
  const _$MakeVolatileTextSafe();

  @override
  String toString() {
    return 'FoodInputEvent.makeVolatileTextSafe()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MakeVolatileTextSafe);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return makeVolatileTextSafe();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return makeVolatileTextSafe?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (makeVolatileTextSafe != null) {
      return makeVolatileTextSafe();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return makeVolatileTextSafe(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return makeVolatileTextSafe?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (makeVolatileTextSafe != null) {
      return makeVolatileTextSafe(this);
    }
    return orElse();
  }
}

abstract class MakeVolatileTextSafe implements FoodInputEvent {
  const factory MakeVolatileTextSafe() = _$MakeVolatileTextSafe;
}

/// @nodoc
abstract class $BuildFragmentsCopyWith<$Res> {
  factory $BuildFragmentsCopyWith(
          BuildFragments value, $Res Function(BuildFragments) then) =
      _$BuildFragmentsCopyWithImpl<$Res>;
}

/// @nodoc
class _$BuildFragmentsCopyWithImpl<$Res>
    extends _$FoodInputEventCopyWithImpl<$Res>
    implements $BuildFragmentsCopyWith<$Res> {
  _$BuildFragmentsCopyWithImpl(
      BuildFragments _value, $Res Function(BuildFragments) _then)
      : super(_value, (v) => _then(v as BuildFragments));

  @override
  BuildFragments get _value => super._value as BuildFragments;
}

/// @nodoc

class _$BuildFragments implements BuildFragments {
  const _$BuildFragments();

  @override
  String toString() {
    return 'FoodInputEvent.buildFragments()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is BuildFragments);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return buildFragments();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return buildFragments?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (buildFragments != null) {
      return buildFragments();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return buildFragments(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return buildFragments?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (buildFragments != null) {
      return buildFragments(this);
    }
    return orElse();
  }
}

abstract class BuildFragments implements FoodInputEvent {
  const factory BuildFragments() = _$BuildFragments;
}

/// @nodoc
abstract class $ApplyFragmentsCopyWith<$Res> {
  factory $ApplyFragmentsCopyWith(
          ApplyFragments value, $Res Function(ApplyFragments) then) =
      _$ApplyFragmentsCopyWithImpl<$Res>;
  $Res call({FragmentizationResult fragmentizationResult});

  $FragmentizationResultCopyWith<$Res> get fragmentizationResult;
}

/// @nodoc
class _$ApplyFragmentsCopyWithImpl<$Res>
    extends _$FoodInputEventCopyWithImpl<$Res>
    implements $ApplyFragmentsCopyWith<$Res> {
  _$ApplyFragmentsCopyWithImpl(
      ApplyFragments _value, $Res Function(ApplyFragments) _then)
      : super(_value, (v) => _then(v as ApplyFragments));

  @override
  ApplyFragments get _value => super._value as ApplyFragments;

  @override
  $Res call({
    Object? fragmentizationResult = freezed,
  }) {
    return _then(ApplyFragments(
      fragmentizationResult == freezed
          ? _value.fragmentizationResult
          : fragmentizationResult // ignore: cast_nullable_to_non_nullable
              as FragmentizationResult,
    ));
  }

  @override
  $FragmentizationResultCopyWith<$Res> get fragmentizationResult {
    return $FragmentizationResultCopyWith<$Res>(_value.fragmentizationResult,
        (value) {
      return _then(_value.copyWith(fragmentizationResult: value));
    });
  }
}

/// @nodoc

class _$ApplyFragments implements ApplyFragments {
  const _$ApplyFragments(this.fragmentizationResult);

  @override
  final FragmentizationResult fragmentizationResult;

  @override
  String toString() {
    return 'FoodInputEvent.applyFragments(fragmentizationResult: $fragmentizationResult)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApplyFragments &&
            const DeepCollectionEquality()
                .equals(other.fragmentizationResult, fragmentizationResult));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(fragmentizationResult));

  @JsonKey(ignore: true)
  @override
  $ApplyFragmentsCopyWith<ApplyFragments> get copyWith =>
      _$ApplyFragmentsCopyWithImpl<ApplyFragments>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return applyFragments(fragmentizationResult);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return applyFragments?.call(fragmentizationResult);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (applyFragments != null) {
      return applyFragments(fragmentizationResult);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return applyFragments(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return applyFragments?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (applyFragments != null) {
      return applyFragments(this);
    }
    return orElse();
  }
}

abstract class ApplyFragments implements FoodInputEvent {
  const factory ApplyFragments(FragmentizationResult fragmentizationResult) =
      _$ApplyFragments;

  FragmentizationResult get fragmentizationResult;
  @JsonKey(ignore: true)
  $ApplyFragmentsCopyWith<ApplyFragments> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FetchFoodForFoodItemEntryCopyWith<$Res> {
  factory $FetchFoodForFoodItemEntryCopyWith(FetchFoodForFoodItemEntry value,
          $Res Function(FetchFoodForFoodItemEntry) then) =
      _$FetchFoodForFoodItemEntryCopyWithImpl<$Res>;
  $Res call({FoodItemEntryPreSuccess foodItemEntryPreSuccess});
}

/// @nodoc
class _$FetchFoodForFoodItemEntryCopyWithImpl<$Res>
    extends _$FoodInputEventCopyWithImpl<$Res>
    implements $FetchFoodForFoodItemEntryCopyWith<$Res> {
  _$FetchFoodForFoodItemEntryCopyWithImpl(FetchFoodForFoodItemEntry _value,
      $Res Function(FetchFoodForFoodItemEntry) _then)
      : super(_value, (v) => _then(v as FetchFoodForFoodItemEntry));

  @override
  FetchFoodForFoodItemEntry get _value =>
      super._value as FetchFoodForFoodItemEntry;

  @override
  $Res call({
    Object? foodItemEntryPreSuccess = freezed,
  }) {
    return _then(FetchFoodForFoodItemEntry(
      foodItemEntryPreSuccess == freezed
          ? _value.foodItemEntryPreSuccess
          : foodItemEntryPreSuccess // ignore: cast_nullable_to_non_nullable
              as FoodItemEntryPreSuccess,
    ));
  }
}

/// @nodoc

class _$FetchFoodForFoodItemEntry implements FetchFoodForFoodItemEntry {
  const _$FetchFoodForFoodItemEntry(this.foodItemEntryPreSuccess);

  @override
  final FoodItemEntryPreSuccess foodItemEntryPreSuccess;

  @override
  String toString() {
    return 'FoodInputEvent.fetchFoodForFoodItemEntry(foodItemEntryPreSuccess: $foodItemEntryPreSuccess)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FetchFoodForFoodItemEntry &&
            const DeepCollectionEquality().equals(
                other.foodItemEntryPreSuccess, foodItemEntryPreSuccess));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(foodItemEntryPreSuccess));

  @JsonKey(ignore: true)
  @override
  $FetchFoodForFoodItemEntryCopyWith<FetchFoodForFoodItemEntry> get copyWith =>
      _$FetchFoodForFoodItemEntryCopyWithImpl<FetchFoodForFoodItemEntry>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFragments,
    required TResult Function(FragmentizationResult fragmentizationResult)
        applyFragments,
    required TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)
        fetchFoodForFoodItemEntry,
  }) {
    return fetchFoodForFoodItemEntry(foodItemEntryPreSuccess);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
  }) {
    return fetchFoodForFoodItemEntry?.call(foodItemEntryPreSuccess);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFragments,
    TResult Function(FragmentizationResult fragmentizationResult)?
        applyFragments,
    TResult Function(FoodItemEntryPreSuccess foodItemEntryPreSuccess)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (fetchFoodForFoodItemEntry != null) {
      return fetchFoodForFoodItemEntry(foodItemEntryPreSuccess);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFragments value) buildFragments,
    required TResult Function(ApplyFragments value) applyFragments,
    required TResult Function(FetchFoodForFoodItemEntry value)
        fetchFoodForFoodItemEntry,
  }) {
    return fetchFoodForFoodItemEntry(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
  }) {
    return fetchFoodForFoodItemEntry?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFragments value)? buildFragments,
    TResult Function(ApplyFragments value)? applyFragments,
    TResult Function(FetchFoodForFoodItemEntry value)?
        fetchFoodForFoodItemEntry,
    required TResult orElse(),
  }) {
    if (fetchFoodForFoodItemEntry != null) {
      return fetchFoodForFoodItemEntry(this);
    }
    return orElse();
  }
}

abstract class FetchFoodForFoodItemEntry implements FoodInputEvent {
  const factory FetchFoodForFoodItemEntry(
          FoodItemEntryPreSuccess foodItemEntryPreSuccess) =
      _$FetchFoodForFoodItemEntry;

  FoodItemEntryPreSuccess get foodItemEntryPreSuccess;
  @JsonKey(ignore: true)
  $FetchFoodForFoodItemEntryCopyWith<FetchFoodForFoodItemEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$FoodInputStateTearOff {
  const _$FoodInputStateTearOff();

  _FoodInputState call(
      {required String safeTextClosed,
      required String safeTextOpen,
      required String volatileText,
      required KtList<FoodItemEntry> safeFoodItemEntries,
      required KtList<FoodItemEntry> volatileFoodItemEntries}) {
    return _FoodInputState(
      safeTextClosed: safeTextClosed,
      safeTextOpen: safeTextOpen,
      volatileText: volatileText,
      safeFoodItemEntries: safeFoodItemEntries,
      volatileFoodItemEntries: volatileFoodItemEntries,
    );
  }
}

/// @nodoc
const $FoodInputState = _$FoodInputStateTearOff();

/// @nodoc
mixin _$FoodInputState {
  String get safeTextClosed => throw _privateConstructorUsedError;
  String get safeTextOpen => throw _privateConstructorUsedError;
  String get volatileText => throw _privateConstructorUsedError;
  KtList<FoodItemEntry> get safeFoodItemEntries =>
      throw _privateConstructorUsedError;
  KtList<FoodItemEntry> get volatileFoodItemEntries =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FoodInputStateCopyWith<FoodInputState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoodInputStateCopyWith<$Res> {
  factory $FoodInputStateCopyWith(
          FoodInputState value, $Res Function(FoodInputState) then) =
      _$FoodInputStateCopyWithImpl<$Res>;
  $Res call(
      {String safeTextClosed,
      String safeTextOpen,
      String volatileText,
      KtList<FoodItemEntry> safeFoodItemEntries,
      KtList<FoodItemEntry> volatileFoodItemEntries});
}

/// @nodoc
class _$FoodInputStateCopyWithImpl<$Res>
    implements $FoodInputStateCopyWith<$Res> {
  _$FoodInputStateCopyWithImpl(this._value, this._then);

  final FoodInputState _value;
  // ignore: unused_field
  final $Res Function(FoodInputState) _then;

  @override
  $Res call({
    Object? safeTextClosed = freezed,
    Object? safeTextOpen = freezed,
    Object? volatileText = freezed,
    Object? safeFoodItemEntries = freezed,
    Object? volatileFoodItemEntries = freezed,
  }) {
    return _then(_value.copyWith(
      safeTextClosed: safeTextClosed == freezed
          ? _value.safeTextClosed
          : safeTextClosed // ignore: cast_nullable_to_non_nullable
              as String,
      safeTextOpen: safeTextOpen == freezed
          ? _value.safeTextOpen
          : safeTextOpen // ignore: cast_nullable_to_non_nullable
              as String,
      volatileText: volatileText == freezed
          ? _value.volatileText
          : volatileText // ignore: cast_nullable_to_non_nullable
              as String,
      safeFoodItemEntries: safeFoodItemEntries == freezed
          ? _value.safeFoodItemEntries
          : safeFoodItemEntries // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItemEntry>,
      volatileFoodItemEntries: volatileFoodItemEntries == freezed
          ? _value.volatileFoodItemEntries
          : volatileFoodItemEntries // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItemEntry>,
    ));
  }
}

/// @nodoc
abstract class _$FoodInputStateCopyWith<$Res>
    implements $FoodInputStateCopyWith<$Res> {
  factory _$FoodInputStateCopyWith(
          _FoodInputState value, $Res Function(_FoodInputState) then) =
      __$FoodInputStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String safeTextClosed,
      String safeTextOpen,
      String volatileText,
      KtList<FoodItemEntry> safeFoodItemEntries,
      KtList<FoodItemEntry> volatileFoodItemEntries});
}

/// @nodoc
class __$FoodInputStateCopyWithImpl<$Res>
    extends _$FoodInputStateCopyWithImpl<$Res>
    implements _$FoodInputStateCopyWith<$Res> {
  __$FoodInputStateCopyWithImpl(
      _FoodInputState _value, $Res Function(_FoodInputState) _then)
      : super(_value, (v) => _then(v as _FoodInputState));

  @override
  _FoodInputState get _value => super._value as _FoodInputState;

  @override
  $Res call({
    Object? safeTextClosed = freezed,
    Object? safeTextOpen = freezed,
    Object? volatileText = freezed,
    Object? safeFoodItemEntries = freezed,
    Object? volatileFoodItemEntries = freezed,
  }) {
    return _then(_FoodInputState(
      safeTextClosed: safeTextClosed == freezed
          ? _value.safeTextClosed
          : safeTextClosed // ignore: cast_nullable_to_non_nullable
              as String,
      safeTextOpen: safeTextOpen == freezed
          ? _value.safeTextOpen
          : safeTextOpen // ignore: cast_nullable_to_non_nullable
              as String,
      volatileText: volatileText == freezed
          ? _value.volatileText
          : volatileText // ignore: cast_nullable_to_non_nullable
              as String,
      safeFoodItemEntries: safeFoodItemEntries == freezed
          ? _value.safeFoodItemEntries
          : safeFoodItemEntries // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItemEntry>,
      volatileFoodItemEntries: volatileFoodItemEntries == freezed
          ? _value.volatileFoodItemEntries
          : volatileFoodItemEntries // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItemEntry>,
    ));
  }
}

/// @nodoc

class _$_FoodInputState extends _FoodInputState {
  const _$_FoodInputState(
      {required this.safeTextClosed,
      required this.safeTextOpen,
      required this.volatileText,
      required this.safeFoodItemEntries,
      required this.volatileFoodItemEntries})
      : super._();

  @override
  final String safeTextClosed;
  @override
  final String safeTextOpen;
  @override
  final String volatileText;
  @override
  final KtList<FoodItemEntry> safeFoodItemEntries;
  @override
  final KtList<FoodItemEntry> volatileFoodItemEntries;

  @override
  String toString() {
    return 'FoodInputState(safeTextClosed: $safeTextClosed, safeTextOpen: $safeTextOpen, volatileText: $volatileText, safeFoodItemEntries: $safeFoodItemEntries, volatileFoodItemEntries: $volatileFoodItemEntries)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FoodInputState &&
            const DeepCollectionEquality()
                .equals(other.safeTextClosed, safeTextClosed) &&
            const DeepCollectionEquality()
                .equals(other.safeTextOpen, safeTextOpen) &&
            const DeepCollectionEquality()
                .equals(other.volatileText, volatileText) &&
            const DeepCollectionEquality()
                .equals(other.safeFoodItemEntries, safeFoodItemEntries) &&
            const DeepCollectionEquality().equals(
                other.volatileFoodItemEntries, volatileFoodItemEntries));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(safeTextClosed),
      const DeepCollectionEquality().hash(safeTextOpen),
      const DeepCollectionEquality().hash(volatileText),
      const DeepCollectionEquality().hash(safeFoodItemEntries),
      const DeepCollectionEquality().hash(volatileFoodItemEntries));

  @JsonKey(ignore: true)
  @override
  _$FoodInputStateCopyWith<_FoodInputState> get copyWith =>
      __$FoodInputStateCopyWithImpl<_FoodInputState>(this, _$identity);
}

abstract class _FoodInputState extends FoodInputState {
  const factory _FoodInputState(
          {required String safeTextClosed,
          required String safeTextOpen,
          required String volatileText,
          required KtList<FoodItemEntry> safeFoodItemEntries,
          required KtList<FoodItemEntry> volatileFoodItemEntries}) =
      _$_FoodInputState;
  const _FoodInputState._() : super._();

  @override
  String get safeTextClosed;
  @override
  String get safeTextOpen;
  @override
  String get volatileText;
  @override
  KtList<FoodItemEntry> get safeFoodItemEntries;
  @override
  KtList<FoodItemEntry> get volatileFoodItemEntries;
  @override
  @JsonKey(ignore: true)
  _$FoodInputStateCopyWith<_FoodInputState> get copyWith =>
      throw _privateConstructorUsedError;
}
