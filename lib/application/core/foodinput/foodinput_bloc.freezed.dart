// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'foodinput_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FoodinputEventTearOff {
  const _$FoodinputEventTearOff();

  Reset reset() {
    return const Reset();
  }

  SetVolatileText setVolatileText(String text) {
    return SetVolatileText(
      text,
    );
  }

  MakeVolatileTextSafe makeVolatileTextSafe() {
    return const MakeVolatileTextSafe();
  }

  BuildFoodItemStrings buildFoodItemStrings() {
    return const BuildFoodItemStrings();
  }

  ApplyFoodItemStrings applyFoodItemStrings(
      KtList<Tuple2<IntRange, FoodItemString>> items) {
    return ApplyFoodItemStrings(
      items,
    );
  }
}

/// @nodoc
const $FoodinputEvent = _$FoodinputEventTearOff();

/// @nodoc
mixin _$FoodinputEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoodinputEventCopyWith<$Res> {
  factory $FoodinputEventCopyWith(
          FoodinputEvent value, $Res Function(FoodinputEvent) then) =
      _$FoodinputEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$FoodinputEventCopyWithImpl<$Res>
    implements $FoodinputEventCopyWith<$Res> {
  _$FoodinputEventCopyWithImpl(this._value, this._then);

  final FoodinputEvent _value;
  // ignore: unused_field
  final $Res Function(FoodinputEvent) _then;
}

/// @nodoc
abstract class $ResetCopyWith<$Res> {
  factory $ResetCopyWith(Reset value, $Res Function(Reset) then) =
      _$ResetCopyWithImpl<$Res>;
}

/// @nodoc
class _$ResetCopyWithImpl<$Res> extends _$FoodinputEventCopyWithImpl<$Res>
    implements $ResetCopyWith<$Res> {
  _$ResetCopyWithImpl(Reset _value, $Res Function(Reset) _then)
      : super(_value, (v) => _then(v as Reset));

  @override
  Reset get _value => super._value as Reset;
}

/// @nodoc

class _$Reset implements Reset {
  const _$Reset();

  @override
  String toString() {
    return 'FoodinputEvent.reset()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Reset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class Reset implements FoodinputEvent {
  const factory Reset() = _$Reset;
}

/// @nodoc
abstract class $SetVolatileTextCopyWith<$Res> {
  factory $SetVolatileTextCopyWith(
          SetVolatileText value, $Res Function(SetVolatileText) then) =
      _$SetVolatileTextCopyWithImpl<$Res>;
  $Res call({String text});
}

/// @nodoc
class _$SetVolatileTextCopyWithImpl<$Res>
    extends _$FoodinputEventCopyWithImpl<$Res>
    implements $SetVolatileTextCopyWith<$Res> {
  _$SetVolatileTextCopyWithImpl(
      SetVolatileText _value, $Res Function(SetVolatileText) _then)
      : super(_value, (v) => _then(v as SetVolatileText));

  @override
  SetVolatileText get _value => super._value as SetVolatileText;

  @override
  $Res call({
    Object? text = freezed,
  }) {
    return _then(SetVolatileText(
      text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SetVolatileText implements SetVolatileText {
  const _$SetVolatileText(this.text);

  @override
  final String text;

  @override
  String toString() {
    return 'FoodinputEvent.setVolatileText(text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetVolatileText &&
            const DeepCollectionEquality().equals(other.text, text));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(text));

  @JsonKey(ignore: true)
  @override
  $SetVolatileTextCopyWith<SetVolatileText> get copyWith =>
      _$SetVolatileTextCopyWithImpl<SetVolatileText>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) {
    return setVolatileText(text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) {
    return setVolatileText?.call(text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (setVolatileText != null) {
      return setVolatileText(text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) {
    return setVolatileText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) {
    return setVolatileText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (setVolatileText != null) {
      return setVolatileText(this);
    }
    return orElse();
  }
}

abstract class SetVolatileText implements FoodinputEvent {
  const factory SetVolatileText(String text) = _$SetVolatileText;

  String get text;
  @JsonKey(ignore: true)
  $SetVolatileTextCopyWith<SetVolatileText> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MakeVolatileTextSafeCopyWith<$Res> {
  factory $MakeVolatileTextSafeCopyWith(MakeVolatileTextSafe value,
          $Res Function(MakeVolatileTextSafe) then) =
      _$MakeVolatileTextSafeCopyWithImpl<$Res>;
}

/// @nodoc
class _$MakeVolatileTextSafeCopyWithImpl<$Res>
    extends _$FoodinputEventCopyWithImpl<$Res>
    implements $MakeVolatileTextSafeCopyWith<$Res> {
  _$MakeVolatileTextSafeCopyWithImpl(
      MakeVolatileTextSafe _value, $Res Function(MakeVolatileTextSafe) _then)
      : super(_value, (v) => _then(v as MakeVolatileTextSafe));

  @override
  MakeVolatileTextSafe get _value => super._value as MakeVolatileTextSafe;
}

/// @nodoc

class _$MakeVolatileTextSafe implements MakeVolatileTextSafe {
  const _$MakeVolatileTextSafe();

  @override
  String toString() {
    return 'FoodinputEvent.makeVolatileTextSafe()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MakeVolatileTextSafe);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) {
    return makeVolatileTextSafe();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) {
    return makeVolatileTextSafe?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (makeVolatileTextSafe != null) {
      return makeVolatileTextSafe();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) {
    return makeVolatileTextSafe(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) {
    return makeVolatileTextSafe?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (makeVolatileTextSafe != null) {
      return makeVolatileTextSafe(this);
    }
    return orElse();
  }
}

abstract class MakeVolatileTextSafe implements FoodinputEvent {
  const factory MakeVolatileTextSafe() = _$MakeVolatileTextSafe;
}

/// @nodoc
abstract class $BuildFoodItemStringsCopyWith<$Res> {
  factory $BuildFoodItemStringsCopyWith(BuildFoodItemStrings value,
          $Res Function(BuildFoodItemStrings) then) =
      _$BuildFoodItemStringsCopyWithImpl<$Res>;
}

/// @nodoc
class _$BuildFoodItemStringsCopyWithImpl<$Res>
    extends _$FoodinputEventCopyWithImpl<$Res>
    implements $BuildFoodItemStringsCopyWith<$Res> {
  _$BuildFoodItemStringsCopyWithImpl(
      BuildFoodItemStrings _value, $Res Function(BuildFoodItemStrings) _then)
      : super(_value, (v) => _then(v as BuildFoodItemStrings));

  @override
  BuildFoodItemStrings get _value => super._value as BuildFoodItemStrings;
}

/// @nodoc

class _$BuildFoodItemStrings implements BuildFoodItemStrings {
  const _$BuildFoodItemStrings();

  @override
  String toString() {
    return 'FoodinputEvent.buildFoodItemStrings()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is BuildFoodItemStrings);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) {
    return buildFoodItemStrings();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) {
    return buildFoodItemStrings?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (buildFoodItemStrings != null) {
      return buildFoodItemStrings();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) {
    return buildFoodItemStrings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) {
    return buildFoodItemStrings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (buildFoodItemStrings != null) {
      return buildFoodItemStrings(this);
    }
    return orElse();
  }
}

abstract class BuildFoodItemStrings implements FoodinputEvent {
  const factory BuildFoodItemStrings() = _$BuildFoodItemStrings;
}

/// @nodoc
abstract class $ApplyFoodItemStringsCopyWith<$Res> {
  factory $ApplyFoodItemStringsCopyWith(ApplyFoodItemStrings value,
          $Res Function(ApplyFoodItemStrings) then) =
      _$ApplyFoodItemStringsCopyWithImpl<$Res>;
  $Res call({KtList<Tuple2<IntRange, FoodItemString>> items});
}

/// @nodoc
class _$ApplyFoodItemStringsCopyWithImpl<$Res>
    extends _$FoodinputEventCopyWithImpl<$Res>
    implements $ApplyFoodItemStringsCopyWith<$Res> {
  _$ApplyFoodItemStringsCopyWithImpl(
      ApplyFoodItemStrings _value, $Res Function(ApplyFoodItemStrings) _then)
      : super(_value, (v) => _then(v as ApplyFoodItemStrings));

  @override
  ApplyFoodItemStrings get _value => super._value as ApplyFoodItemStrings;

  @override
  $Res call({
    Object? items = freezed,
  }) {
    return _then(ApplyFoodItemStrings(
      items == freezed
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as KtList<Tuple2<IntRange, FoodItemString>>,
    ));
  }
}

/// @nodoc

class _$ApplyFoodItemStrings implements ApplyFoodItemStrings {
  const _$ApplyFoodItemStrings(this.items);

  @override
  final KtList<Tuple2<IntRange, FoodItemString>> items;

  @override
  String toString() {
    return 'FoodinputEvent.applyFoodItemStrings(items: $items)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApplyFoodItemStrings &&
            const DeepCollectionEquality().equals(other.items, items));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(items));

  @JsonKey(ignore: true)
  @override
  $ApplyFoodItemStringsCopyWith<ApplyFoodItemStrings> get copyWith =>
      _$ApplyFoodItemStringsCopyWithImpl<ApplyFoodItemStrings>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(String text) setVolatileText,
    required TResult Function() makeVolatileTextSafe,
    required TResult Function() buildFoodItemStrings,
    required TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)
        applyFoodItemStrings,
  }) {
    return applyFoodItemStrings(items);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
  }) {
    return applyFoodItemStrings?.call(items);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(String text)? setVolatileText,
    TResult Function()? makeVolatileTextSafe,
    TResult Function()? buildFoodItemStrings,
    TResult Function(KtList<Tuple2<IntRange, FoodItemString>> items)?
        applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (applyFoodItemStrings != null) {
      return applyFoodItemStrings(items);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Reset value) reset,
    required TResult Function(SetVolatileText value) setVolatileText,
    required TResult Function(MakeVolatileTextSafe value) makeVolatileTextSafe,
    required TResult Function(BuildFoodItemStrings value) buildFoodItemStrings,
    required TResult Function(ApplyFoodItemStrings value) applyFoodItemStrings,
  }) {
    return applyFoodItemStrings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
  }) {
    return applyFoodItemStrings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Reset value)? reset,
    TResult Function(SetVolatileText value)? setVolatileText,
    TResult Function(MakeVolatileTextSafe value)? makeVolatileTextSafe,
    TResult Function(BuildFoodItemStrings value)? buildFoodItemStrings,
    TResult Function(ApplyFoodItemStrings value)? applyFoodItemStrings,
    required TResult orElse(),
  }) {
    if (applyFoodItemStrings != null) {
      return applyFoodItemStrings(this);
    }
    return orElse();
  }
}

abstract class ApplyFoodItemStrings implements FoodinputEvent {
  const factory ApplyFoodItemStrings(
      KtList<Tuple2<IntRange, FoodItemString>> items) = _$ApplyFoodItemStrings;

  KtList<Tuple2<IntRange, FoodItemString>> get items;
  @JsonKey(ignore: true)
  $ApplyFoodItemStringsCopyWith<ApplyFoodItemStrings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$FoodinputStateTearOff {
  const _$FoodinputStateTearOff();

  _FoodinputState call(
      {required String safeTextClosed,
      required String safeTextOpen,
      required String volatileText,
      required KtList<FoodItem> safeFoodItems,
      required KtList<FoodItem> volatileFoodItems}) {
    return _FoodinputState(
      safeTextClosed: safeTextClosed,
      safeTextOpen: safeTextOpen,
      volatileText: volatileText,
      safeFoodItems: safeFoodItems,
      volatileFoodItems: volatileFoodItems,
    );
  }
}

/// @nodoc
const $FoodinputState = _$FoodinputStateTearOff();

/// @nodoc
mixin _$FoodinputState {
  String get safeTextClosed => throw _privateConstructorUsedError;
  String get safeTextOpen => throw _privateConstructorUsedError;
  String get volatileText => throw _privateConstructorUsedError;
  KtList<FoodItem> get safeFoodItems => throw _privateConstructorUsedError;
  KtList<FoodItem> get volatileFoodItems => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FoodinputStateCopyWith<FoodinputState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoodinputStateCopyWith<$Res> {
  factory $FoodinputStateCopyWith(
          FoodinputState value, $Res Function(FoodinputState) then) =
      _$FoodinputStateCopyWithImpl<$Res>;
  $Res call(
      {String safeTextClosed,
      String safeTextOpen,
      String volatileText,
      KtList<FoodItem> safeFoodItems,
      KtList<FoodItem> volatileFoodItems});
}

/// @nodoc
class _$FoodinputStateCopyWithImpl<$Res>
    implements $FoodinputStateCopyWith<$Res> {
  _$FoodinputStateCopyWithImpl(this._value, this._then);

  final FoodinputState _value;
  // ignore: unused_field
  final $Res Function(FoodinputState) _then;

  @override
  $Res call({
    Object? safeTextClosed = freezed,
    Object? safeTextOpen = freezed,
    Object? volatileText = freezed,
    Object? safeFoodItems = freezed,
    Object? volatileFoodItems = freezed,
  }) {
    return _then(_value.copyWith(
      safeTextClosed: safeTextClosed == freezed
          ? _value.safeTextClosed
          : safeTextClosed // ignore: cast_nullable_to_non_nullable
              as String,
      safeTextOpen: safeTextOpen == freezed
          ? _value.safeTextOpen
          : safeTextOpen // ignore: cast_nullable_to_non_nullable
              as String,
      volatileText: volatileText == freezed
          ? _value.volatileText
          : volatileText // ignore: cast_nullable_to_non_nullable
              as String,
      safeFoodItems: safeFoodItems == freezed
          ? _value.safeFoodItems
          : safeFoodItems // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItem>,
      volatileFoodItems: volatileFoodItems == freezed
          ? _value.volatileFoodItems
          : volatileFoodItems // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItem>,
    ));
  }
}

/// @nodoc
abstract class _$FoodinputStateCopyWith<$Res>
    implements $FoodinputStateCopyWith<$Res> {
  factory _$FoodinputStateCopyWith(
          _FoodinputState value, $Res Function(_FoodinputState) then) =
      __$FoodinputStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String safeTextClosed,
      String safeTextOpen,
      String volatileText,
      KtList<FoodItem> safeFoodItems,
      KtList<FoodItem> volatileFoodItems});
}

/// @nodoc
class __$FoodinputStateCopyWithImpl<$Res>
    extends _$FoodinputStateCopyWithImpl<$Res>
    implements _$FoodinputStateCopyWith<$Res> {
  __$FoodinputStateCopyWithImpl(
      _FoodinputState _value, $Res Function(_FoodinputState) _then)
      : super(_value, (v) => _then(v as _FoodinputState));

  @override
  _FoodinputState get _value => super._value as _FoodinputState;

  @override
  $Res call({
    Object? safeTextClosed = freezed,
    Object? safeTextOpen = freezed,
    Object? volatileText = freezed,
    Object? safeFoodItems = freezed,
    Object? volatileFoodItems = freezed,
  }) {
    return _then(_FoodinputState(
      safeTextClosed: safeTextClosed == freezed
          ? _value.safeTextClosed
          : safeTextClosed // ignore: cast_nullable_to_non_nullable
              as String,
      safeTextOpen: safeTextOpen == freezed
          ? _value.safeTextOpen
          : safeTextOpen // ignore: cast_nullable_to_non_nullable
              as String,
      volatileText: volatileText == freezed
          ? _value.volatileText
          : volatileText // ignore: cast_nullable_to_non_nullable
              as String,
      safeFoodItems: safeFoodItems == freezed
          ? _value.safeFoodItems
          : safeFoodItems // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItem>,
      volatileFoodItems: volatileFoodItems == freezed
          ? _value.volatileFoodItems
          : volatileFoodItems // ignore: cast_nullable_to_non_nullable
              as KtList<FoodItem>,
    ));
  }
}

/// @nodoc

class _$_FoodinputState implements _FoodinputState {
  const _$_FoodinputState(
      {required this.safeTextClosed,
      required this.safeTextOpen,
      required this.volatileText,
      required this.safeFoodItems,
      required this.volatileFoodItems});

  @override
  final String safeTextClosed;
  @override
  final String safeTextOpen;
  @override
  final String volatileText;
  @override
  final KtList<FoodItem> safeFoodItems;
  @override
  final KtList<FoodItem> volatileFoodItems;

  @override
  String toString() {
    return 'FoodinputState(safeTextClosed: $safeTextClosed, safeTextOpen: $safeTextOpen, volatileText: $volatileText, safeFoodItems: $safeFoodItems, volatileFoodItems: $volatileFoodItems)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FoodinputState &&
            const DeepCollectionEquality()
                .equals(other.safeTextClosed, safeTextClosed) &&
            const DeepCollectionEquality()
                .equals(other.safeTextOpen, safeTextOpen) &&
            const DeepCollectionEquality()
                .equals(other.volatileText, volatileText) &&
            const DeepCollectionEquality()
                .equals(other.safeFoodItems, safeFoodItems) &&
            const DeepCollectionEquality()
                .equals(other.volatileFoodItems, volatileFoodItems));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(safeTextClosed),
      const DeepCollectionEquality().hash(safeTextOpen),
      const DeepCollectionEquality().hash(volatileText),
      const DeepCollectionEquality().hash(safeFoodItems),
      const DeepCollectionEquality().hash(volatileFoodItems));

  @JsonKey(ignore: true)
  @override
  _$FoodinputStateCopyWith<_FoodinputState> get copyWith =>
      __$FoodinputStateCopyWithImpl<_FoodinputState>(this, _$identity);
}

abstract class _FoodinputState implements FoodinputState {
  const factory _FoodinputState(
      {required String safeTextClosed,
      required String safeTextOpen,
      required String volatileText,
      required KtList<FoodItem> safeFoodItems,
      required KtList<FoodItem> volatileFoodItems}) = _$_FoodinputState;

  @override
  String get safeTextClosed;
  @override
  String get safeTextOpen;
  @override
  String get volatileText;
  @override
  KtList<FoodItem> get safeFoodItems;
  @override
  KtList<FoodItem> get volatileFoodItems;
  @override
  @JsonKey(ignore: true)
  _$FoodinputStateCopyWith<_FoodinputState> get copyWith =>
      throw _privateConstructorUsedError;
}
